Linguagem de Programação Snask - Documentação Oficial (pt-BR)
Introdução
Snask é uma linguagem de script imperativa e simples, projetada para facilidade de uso e aprendizado. Ela possui tipos de dados básicos, estruturas de controle de fluxo, funções, estruturas de dados como listas (packs) e dicionários (boxes), E/S (Entrada/Saída) de arquivos e um mecanismo para usar bibliotecas externas.
Este documento descreve a sintaxe e a semântica da linguagem Snask conforme implementada pelo script snask_interpreter.py.
Conceitos Fundamentais
Instruções (Statements): Programas Snask são sequências de instruções. Cada instrução normalmente ocupa uma linha, mas blocos de controle de fluxo (when, spin, loopy, craft) contêm múltiplas instruções indentadas (embora a indentação não seja estritamente necessária pela gramática Lark fornecida, ela é crucial para a legibilidade e implícita pela estrutura stmt+ após um :).
Tipagem Dinâmica: Variáveis não têm um tipo fixo declarado previamente. Seu tipo é determinado pelo valor atribuído a elas e pode mudar durante a execução.
Sensibilidade a Maiúsculas/Minúsculas (Case-Sensitivity): As palavras-chave (make, shoo, when, etc.) são minúsculas. Nomes de variáveis e funções (NAME) são sensíveis a maiúsculas e minúsculas (diferenciam "variavel" de "Variavel").
Comentários: (Nota: A gramática fornecida não define explicitamente comentários. Tipicamente, comentários de linha única poderiam começar com # ou //. Isso precisaria ser adicionado à diretiva %ignore da gramática, se desejado).
Tipos de Dados
Snask suporta os seguintes tipos de dados básicos:
Número (Number): Valores inteiros (ex: 10, -5, 0). Representado pelo token NUMBER.
String (Texto): Sequências de caracteres delimitadas por aspas duplas (ex: "ola", "mundo"). Representado por ESCAPED_STRING.
Lista (Pack): Coleções ordenadas de valores.
Dicionário (Box): Coleções de pares chave-valor.
Variáveis e Constantes
Variáveis armazenam dados que podem ser alterados durante a execução do programa. Constantes são destinadas a armazenar dados que permanecem fixos, embora a implementação atual não reforce estritamente a imutabilidade após a declaração.
Declaração e Inicialização (make)
Sintaxe: make NOME = expressao
Cria uma nova variável chamada NOME e atribui o resultado da expressao a ela.
Exemplo: make pontuacao = 0, make saudacao = "Olá!"
Atribuição (set)
Sintaxe: set NOME = expressao
Atualiza o valor de uma variável existente NOME com o resultado da expressao.
Exemplo: set pontuacao = pontuacao + 10
Remoção (zap)
Sintaxe: zap NOME
Remove a variável NOME do ambiente. Acessá-la posteriormente provavelmente causará um erro ou retornará o próprio nome se não resolvido.
Exemplo: zap variavel_temporaria
Declaração de Constante (keep)
Sintaxe: keep NOME = expressao
Declara uma variável que se pretende ser constante. Atribui o resultado da expressao a NOME. (Nota: Imutabilidade não é forçada pelo interpretador).
Exemplo: keep PI = 3.14159
Entrada/Saída (E/S - I/O)
Imprimir Saída (shoo)
Sintaxe: shoo expressao
Avalia a expressao e imprime sua representação em string no console, seguida por uma nova linha.
Exemplo: shoo "Digite seu nome:", shoo pontuacao
Entrada Genérica (grab)
Sintaxe: grab NOME
Exibe o prompt > para o usuário, lê uma linha de texto do console e a armazena como uma string na variável NOME.
Exemplo: grab nome_usuario
Entrada Numérica (grabnum)
Sintaxe: grabnum NOME
Exibe o prompt >, lê uma linha de texto, tenta convertê-la para um inteiro e armazena o resultado na variável NOME. Causará um erro se a entrada não puder ser convertida para um inteiro.
Exemplo: grabnum idade_usuario
Entrada de Texto (grabtxt)
Sintaxe: grabtxt NOME
Exibe o prompt >, lê uma linha de texto e a armazena como uma string na variável NOME. Funcionalmente idêntico ao grab.
Exemplo: grabtxt cor_favorita
Expressões e Operadores
Expressões produzem valores.
Literais:
Números: 123, -4
Strings: "Olá mundo"
Acesso a Variáveis: Usar o NOME de uma variável avalia para o seu valor atual.
Operadores Aritméticos:
+ (Adição/Concatenação): expressao + expressao
Se ambos os operandos forem números, realiza adição aritmética.
Se qualquer um dos operandos for uma string, converte ambos para strings e os concatena.
- (Subtração): expressao - expressao (Requer operandos numéricos)
* (Multiplicação): expressao * expressao (Requer operandos numéricos)
/ (Divisão): expressao / expressao (Requer operandos numéricos, realiza divisão de ponto flutuante)
Operadores de Comparação:
is (Igualdade): expressao is expressao
Avalia para 1 (verdadeiro) se os valores resolvidos das expressões forem iguais, 0 (falso) caso contrário.
aint (Desigualdade): expressao aint expressao
Avalia para 1 (verdadeiro) se os valores resolvidos das expressões não forem iguais, 0 (falso) caso contrário.
(Nota: A gramática inclui == mapeado para eq, mas não há um método eq correspondente no interpretador. Use is para verificação de igualdade).
Parênteses: ( expressao )
Usados para agrupar expressões e controlar a ordem de avaliação.
Controle de Fluxo
Execução Condicional (when)
Sintaxe:
when expressao_condicao :
    instrucao1
    instrucao2
    ...
Use code with caution.
Snask
Avalia expressao_condicao. Se o resultado for considerado "verdadeiro" (número diferente de zero, potencialmente string/lista/box não vazios - específico do interpretador, tipicamente inteiro não-zero), o bloco de instruções seguinte é executado. Caso contrário, o bloco é pulado.
Exemplo:
when pontuacao is 100 :
    shoo "Pontuação perfeita!"
Use code with caution.
Snask
Loop Condicional (spin)
Sintaxe:
spin expressao_condicao :
    instrucao1
    instrucao2
    ...
Use code with caution.
Snask
Avalia expressao_condicao. Se for verdadeira, o bloco é executado. Após o término do bloco, a condição é avaliada novamente. Isso se repete enquanto a condição permanecer verdadeira. Se a condição for inicialmente falsa, o bloco nunca executa.
Exemplo:
make contador = 0
spin contador aint 5 :
    shoo contador
    set contador = contador + 1
Use code with caution.
Snask
Loop Infinito (loopy)
Sintaxe:
loopy :
    instrucao1
    instrucao2
    ...
Use code with caution.
Snask
Executa o bloco de instruções repetidamente sem uma condição explícita. Requer uma instrução breaky dentro do bloco para terminar.
Exemplo:
loopy :
    grab comando
    when comando is "sair" :
        breaky
    shoo "Processando comando..."
Use code with caution.
Snask
Interrupção de Loop (breaky)
Sintaxe: breaky
Sai imediatamente do loop spin ou loopy mais interno em que está contido. Dentro de funções, também interrompe a execução adicional naquela chamada de função se usado fora de um loop, mas dentro da função (devido ao mecanismo de self.returning).
Pular Iteração (skipit)
Sintaxe: skipit
(Nota: No interpretador fornecido, esta instrução atualmente não faz nada). A funcionalidade pretendida em muitas linguagens é pular o restante da iteração atual do loop e prosseguir para a próxima (ou reavaliar a condição no spin).
Exemplo (Conceitual):
make i = 0
spin i aint 10 :
   set i = i + 1
   when i is 5 :
       skipit // Pula a impressão do 5
   shoo i
Use code with caution.
Snask
Funções
Funções permitem agrupar código em blocos reutilizáveis.
Declaração (craft)
Sintaxe:
craft NOME_FUNCAO :
    instrucao1
    instrucao2
    ...
Use code with caution.
Snask
Define uma função chamada NOME_FUNCAO com o bloco de instruções especificado como seu corpo. Atualmente, as funções não suportam parâmetros diretamente na declaração.
Exemplo:
craft saudar :
    shoo "Olá da função!"
Use code with caution.
Snask
Chamada (NOME)
Sintaxe: NOME_FUNCAO
Executa o corpo da função chamada NOME_FUNCAO.
Exemplo: saudar
Valor de Retorno (back)
Sintaxe: back expressao
Avalia expressao. Interrompe imediatamente a execução da função atual e define o valor de retorno da chamada da função para o resultado da expressao. O mecanismo breaky (self.returning = True) é usado internamente para sinalizar o retorno.
Exemplo:
craft somar_numeros :
    make num1 = 10
    make num2 = 20
    back num1 + num2 // Retorna 30

// make resultado = somar_numeros // 'resultado' não capturará o valor aqui
// shoo resultado             // Provavelmente imprimirá 'somar_numeros' ou None
somar_numeros // A chamada é feita, mas o valor retornado não é capturado facilmente
Use code with caution.
Snask
Nota Importante: O método func_call do interpretador atual retorna um valor, mas a regra da gramática func_call: NAME não o coloca facilmente dentro de um contexto de expressao. Portanto, atribuir diretamente o resultado como make x = minha_funcao não é analisado corretamente pela gramática atual. O return_value é armazenado, mas pode não ser facilmente acessível sem alterações na gramática (por exemplo, permitindo que func_call seja um atom dentro de expr).
Estruturas de Dados
Listas (Packs)
Sequências ordenadas e mutáveis de itens, acessadas por índice inteiro baseado em zero.
Declaração (pack):
Sintaxe: pack NOME = [elem1, elem2, ...]
Exemplo: pack minha_lista = [1, "dois", 3]
Adicionar Elementos (packadd):
Sintaxe: packadd NOME expressao_valor
Anexa o resultado de expressao_valor ao final do pack NOME.
Exemplo: packadd minha_lista 4
Acessar Elementos (packget):
Sintaxe: packget NOME expressao_indice
Avalia expressao_indice (deve ser um número) e retorna o elemento naquele índice no pack NOME. Esta forma é usada principalmente dentro de expressões (embora o método do interpretador retorne o valor, o uso direto pode ser limitado pela gramática, semelhante às funções). Para usar o valor, você pode precisar de uma construção que o interprete como uma expressão.
Dicionários (Boxes)
Coleções de pares chave-valor não ordenadas (na prática do Python < 3.7). Chaves são strings, valores podem ser de qualquer tipo.
Declaração (box):
Sintaxe: box NOME = {chave1: valor1, chave2: valor2, ...} (Note que as chaves na sintaxe são NAME, não strings, mas são tratadas como strings no interpretador).
Exemplo: box meu_dicionario = {nome: "Alice", idade: 30}
Inserir/Atualizar Elemento (boxput):
Sintaxe: boxput NOME CHAVE expressao_valor (Novamente, CHAVE é um NAME na sintaxe).
Define o valor associado à CHAVE (tratada como string) no box NOME para o resultado de expressao_valor. Se a chave já existir, seu valor é atualizado.
Exemplo: boxput meu_dicionario cidade "Wonderland"
Acessar Elemento (boxget):
Sintaxe: boxget NOME CHAVE
Retorna o valor associado à CHAVE (tratada como string) no box NOME. Similar ao packget, usado principalmente em contextos onde um valor é esperado.
Espera (snooze)
Pausar Execução
Sintaxe: snooze expressao_tempo
Avalia expressao_tempo (deve resultar em um número) e pausa a execução do script por esse número de segundos. Utiliza time.sleep.
Exemplo: snooze 1.5 // Espera por 1.5 segundos
Conversão de Tipos (convert)
Converter Tipo de Variável
Sintaxe: convert NOME to TIPO onde TIPO é int ou str.
Obtém o valor atual da variável NOME, converte-o para o TIPO especificado (int para inteiro, str para string) e atualiza a variável NOME com o valor convertido.
Exemplo:
make valor_texto = "123"
convert valor_texto to int // Agora valor_texto contém o número 123
make numero = 456
convert numero to str     // Agora numero contém a string "456"
Use code with caution.
Snask
Uso de Bibliotecas (to use)
Importar Código Snask Externo
Sintaxe: to use NOME_BIBLIOTECA
Procura por um arquivo chamado NOME_BIBLIOTECA.snask dentro de uma subpasta chamada libs (relativa ao local do script principal).
Se encontrado, o conteúdo do arquivo é lido, analisado (parseado) e interpretado no ambiente atual. Isso significa que quaisquer variáveis, constantes ou funções definidas na biblioteca ficam disponíveis no script que a usou.
Se o arquivo não for encontrado, uma mensagem de erro é exibida.
Exemplo: to use minha_lib_util (procuraria por libs/minha_lib_util.snask)
Manipulação de Arquivos
Leitura de Arquivo (readfile)
Sintaxe: readfile NOME_ARQUIVO to NOME_VARIAVEL
Tenta abrir e ler todo o conteúdo do arquivo especificado por NOME_ARQUIVO (que deve ser uma string ou uma variável contendo o nome do arquivo).
O conteúdo lido é armazenado como uma única string na variável NOME_VARIAVEL.
Se o arquivo não for encontrado, uma mensagem de erro é exibida.
Exemplo: readfile "dados.txt" to conteudo_arquivo
Escrita em Arquivo (writefile)
Sintaxe: writefile NOME_ARQUIVO with expressao_conteudo
Avalia expressao_conteudo para obter o conteúdo a ser escrito (geralmente uma string).
Abre o arquivo especificado por NOME_ARQUIVO (string ou variável) em modo de escrita (sobrescrevendo qualquer conteúdo existente).
Escreve o conteúdo no arquivo.
Se ocorrer um erro durante a escrita, uma mensagem de erro é exibida.
Exemplo: writefile "saida.log" with "Processo concluído."
